using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Lab18_Homework
{
    class Program
    {
        /*
         *  Дана строка, содержащая скобки трёх видов (круглые, квадратные и фигурные) и любые другие символы. 
         *  Проверить, корректно ли в ней расставлены скобки. Например, в строке ([]{})[] скобки расставлены корректно, а в строке ([]] — нет. 
         *  
         *  Указание: задача решается однократным проходом по символам заданной строки слева направо; 
         *  для каждой открывающей скобки в строке в стек помещается соответствующая закрывающая, 
         *  каждая закрывающая скобка в строке должна соответствовать скобке из вершины стека (при этом скобка с вершины стека снимается); 
         *  в конце прохода стек должен быть пуст.
         * */
        static void Main(string[] args)
        {
            Console.WriteLine("Введите строку");
            string str = Console.ReadLine();
            Console.WriteLine(Check(str));
            Console.ReadKey();            
        }

        //Метод логический bool, который возвращает true или falls
        static bool Check (string str)
        {
            //символ
            Stack<char> stack = new Stack<char>();
            //структура данных, в которой происходит сопоставление используемых символов с помощью словаря. По ключу открытой скобки можно получить закрытую скобку
            Dictionary<char, char> sk = new Dictionary<char, char>()
            {
                {'(', ')' },
                {'{', '}' },
                {'[', ']' }
            };

            //если используется определенный вид скобки, то в stack используется соответствующий символ из словаря по индексу
            foreach (var s in stack)
            {
                //для проверки на правильное укладывание (закрытие) открывающихся скобок
                if (s == '(' || s == '{' || s == '[')
                    stack.Push(sk[s]);
                //если стек пустой или элемент лежит на вершине стека и не соответствует виду, то ошибка - прерываем метод
                if (s == ')' || s == '}' || s == ']')
                {
                    if (stack.Count != 0 || stack.Pop()!=s)
                    {
                        return false;
                    }
                }
            }

            //сначала проверит - не остался ли в стеке лишний элемент перед возвращением true
            if (stack.Count != 0)
                return true;
            else
                return false;
        }
    }
}
